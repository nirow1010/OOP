# OOP
JAVA Concepts: Object
[Java 객체지향 노트]
특징 1. 코드의 재사용성이 높다
        2. 유지보수가 용이하다
        3. 중복코드 제거
핵심개념 1. 캡슐화 2. 상속 3. 추상화 4. 다형성 (제일 중요!)
<클래스와 객체>
클래스: 객체를 정의한 설계도 - 객체를 생성하기 위해 씀
             데이터 + 함수 - 서로 관련된 여러데이터를 하나로 묶음
             사용자 정의타입 - 원하는 타입을 만들 수 있음
객체(iv 묶음): 실제로 존재하는 것 (제품). 용도는 기능(변수)와 속성(메서드)에 따라 다름.
인스턴스: 특정 클래스로부터 생성된 객체
클래스를 인스턴스화해서 인스턴스(객체)를 만듬
객체생성: 클래스명 참조변수명 = new 클래스(생성자)명(); (new가 객체 생성, 생성자가 객체 초기화)
객체 배열(참조변수의 배열): 클래스명[] 참조변수명 = new 클래스명[n] 
                                                            클래스명[0] 참조변수 = new 클래스명();.... (꼭 해줘야함)
<변수 종류>
참조변수: 생성된 개체의 주솟값을 저장함 (c의 포인터와 비슷)
클래스 변수(cv)
클래스 영역
클래스가 메모리에 올라갈때 생성됨, 사용하기 위해선 객체 생성이 필요 x
인스턴스 변수(iv)
인스턴스가 생성되었을 때 생성됨
사용하기 위해선 객체 생성이 필요 o
지역변수(lv)
클래스 영역 이외외 영역
변수 선언문이 수행됬을 때 생성됨


인스턴스 변수와 지역변수 이름이 같을때는 사용되는 변수는 호출된 곳으로부터 더 가까운 쪽이다.
<클래스 변수와 인스턴스 변수>
객체의 속성: 객체들의 개별속성이면 (iv) (사용법은 참조변수명.변수이름)
       객체들의 공통속성이면 (cv) (사용법은 클래스명.변수이름)
속성들의 생성법: iv - 변수타입 변수명 = 값
                            cv - static 변수타입 변수명 = 값
iv는 인스턴스가 생성될 때마다 개별적으로 저장되서 서로 다른 값을 가질 수 있지만,
cv는 개별적인 하나의 메모리에 저장되서 모든 객체들끼리 같은 값을 유지한다. 
<메서드> 
문장들을 작업단위로 묶은것
값을 받고 결과를 반환하는 것
위치: 클래스 내부에 있어야 함
장점: 1. 중복코드제거
          2. 관리 용이
          3. 재사용 가능
          4. 간결하고 이해하기 쉬움.
메서드 작성: 무조건 클래스 안에 있어야 함
                     반복되는 여러문장을 메서드로 작성
                     하나의 메서드는 한 가지 기능만 수행하도록 작성해야 함.
메서드 = 선언부 + 구현부
선언부 -  참조변수.반환타입 메서드이름 (매개변수 선언)
구현부 -  {
     메서드 호출 시 실행될 코드 // return으로 결과를 출력(출력값) 
               }
메서드 호출: 메서드이름(값 1, 값 2, …); (매개변수가 없다면 그냥 메서드이름())
메서드 실행흐름
1. 객체생성 → 2. 메서드호출 → 3. 메서드 안 수행문 수행 → 4. 호출한 곳으로 반환
매개변수: 작업에 필요한 값들, 없거나 여러개 있을 수 있다 
메서드 실행흐름
1. 객체생성 → 2. 메서드호출 → 3. 메서드 안 수행문 수행 → 4. 호출한 곳으로 반환
return문
- 실행중인 메소드를 종료하고 호출한 곳으로 출력값을 가지고 돌아간다.
- 반환 타입이 void가 아닌 경우, 반드시 return문 필요
- if문에서는 참일때나 거짓일때나 return문을 써 줘야한다
반환값: 반환타입이 void가 아닌경우, 반환타입과 반환값의 타입을 일치시켜야함. 반환값의 타입이 반환타입으로 자동형변환 가능하면 예외 (예: byte, short, char은 int로 자동형변환 가능)
호출스택
- 스택(stack): 밑이 막힌 상자. 스택에 넣으면 위에 차곡차곡 쌓이고, 뺄때는 위에꺼부터 뺀다.
- 호출 스택(call stack): 메서드 수행에 필요한 메모리가 제공되는 공간
- 메서드가 호출되면 호출스택에 메모리 할당, 종료되면 해제
- 아래있는 메서드가 위의 메서드를 호출했다고 알 수 있음
- 맨위의 메서드만 실행중, 나머지는 대기
기본형 매개변수와 참조형 매개변수
- 기본형(8개) 매개변수: 변수의 값을 읽기만 할 수 있다. (read only)
- 참조형 매개변수: 변수의 값을 변경할 수 있다. (read & write)
참조형 반환타입
- 객체의 주소를 반환한다
- 객체주소를 반환(리모컨 토스)하기에 참조변수가 객체를 다룰 수 있게 됨
<static 메서드와 인스턴스 메서드>
인스턴스 메서드
- 인스턴스 생성후, ‘참조변수.메서드이름()’으로 호출
- 인스턴스 멤버(iv, im)와 관련된 작업을 하는 메서드
- 메서드 내에서 인스턴스 변수(iv) 사용가능
- 생성법: 반환타입 메서드이름(매개변수) {}
static 메서드(클래스 메서드)
- 객체생성없이 ‘클래스이름.메서드이름()’으로 호출
- 인스턴스 멤버(iv, im)와 관련없는 작업을 하는 메서드
- 메서드 내에서 인스턴스 변수(iv) 사용불가
- 생성법: static 반환타입 메서드이름(매개변수) {}
인스턴스 멤버(iv, im)를 사용한다면 인스턴스 메서드로, 사용하지 않는다면 static 메서드로 만든다.
<오버로딩(overloading)>
한 클래스 안에 같은 이름, 다른 매개변수의 메서드 여러 개 정의하는 것
기능: 매개변수는 다르지만 같은 의미의 기능수행 (예: println(123), println(“abc”))
오버로딩 성립조건
1. 메서드 이름이 같아야 한다
2. 매개변수의 개수 또는 타입이 달라야 한다
3. 반환 타입은 영향없다
매개변수에 자동형변환으로 입력이 가능할시 중복이 될 수 있다. 
(예) long add(int a, long b) {} 와 long add(long a, int b) {}에다가 add(3,3)을 넣으면 애매모호해서 컴퓨터가 판단을 못한다
<생성자>
인스턴스가 생성될 때마다 호출되는 ‘인스턴스 초기화 메서드’
인스턴스 생성시 수행할 작업(iv 초기화)에 사용
iv 초기화: iv의 값을 초기화하는 것 (예: c.color = “white”;)
클래스이름 참조변수 = new 클래스이름()에서 클래스이름()도 생성자이다.
생성자는 따로 만들어 줘야 하지만 만들지 않으면 기본생성자가 컴파일러에 의해 자동 생성된다.
규칙: 1. 이름이 클래스 이름과 같아야 한다
          2. 리턴값이 없다. (void 안붙임)
          3. 모든 클래스는 반드시 생성자를 가져야 한다.
생성법: 클래스이름(타입 변수명, 타입 변수명, …) { // 코드 }
생성자에도 오버로딩이 적용된다. 
<기본생성자(default constructor)>
매개변수가 없는 생성자
기본생성자의 구조: 클래스이름() { (비어있음) } 
생성자가 하나도 없을 때만, 컴파일러가 자동 추가 
컴파일러가 자동 추가 해줄수 있지만, 기본생성자는 항상 수동적으로 만들어둬야 한다.
<매개변수가 있는 생성자>
인스턴스 변수를 생성하는 동시에 원하는 값으로 초기화 할 수 있게됨.
인스턴스 생성 후 인스턴스 변수의 값을 초기화 하는것보다 이걸 쓰는게 더 코드가 간결함.
<생성자 this()>
생성자 내에서 다른 생성자(오버로딩 생성자) 호출할 때 사용 (규칙)
다른 생성자 호출시 첫 줄에서만 사용가능 (주석처리한 줄은 제외)
<참조변수 this>
인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되있음 (생성자 this()란 전혀 별개의 것)
인스턴스 메서드(생성자 포함)에서 사용가능 (클래스 메서드에선 불가)
모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다
지역변수(lv)와 인스턴스 변수 (iv)를 구별할 때 사용
<변수의 초기화>
멤버변수의 초기화: 
1. 자동초기화: 변수를 선언했을때 자동적 초기화
2. 간단초기화: 명시적 초기화(=)
3. 복잡초기화: 인스턴스 초기화 블럭 – { }, 클래스 초기화 블럭 – static { }, 생성자
지역변수(lv)는 수동 초기화 해야함 (사용전 꼭!!!) (지역변수는 자동 초기화를 안해주기 때문)
멤버변수(iv, cv)는 자동 초기화된다.
클래스 변수 초기화 시점: 클래스가 처음 로딩될 때 단 한번
인스턴스 변수 초기화 시점: 인스턴스가 생성될 때 마다
멤버변수의 초기화 시기와 순서: 1. cv → iv  
                                                   2. 자동 → 간단 → 복잡
<상속(Inheritance)>
기존의 클래스로 새로운 클래스를 작성하는 것. (코드의 재사용)
두 클래스를 부모와 자식으로 관계를 맺어주는 것.
사용법: class 자식클래스 extends 부모클래스 { // 내용 }
자손은 조상의 모든 멤버를 상속받음. (생성자, 초기화블럭 제외)
자손의 멤버 개수는 조상보다 적을 수 없음 (같거나 많다)
자손의 변경은 조상에 영향을 미치지 않음
<포함(composite)>
클래스의 멤버로 참조변수를 선언하는 것
작은 단위의 클래스를 만들고, 이들을 조합해서 클래스를 만든다.
클래스 간의 관계 결정
1. 상속관계: ‘~은 ~이다. (a is b)’ 
2. 포함관계: ‘~은 ~을 가지고 있다. (a has b)’
- 대부분의 경우 (90%)는 포함을 쓰고, 꼭 필요할때만 상속을 써야한다.
<단일 상속(Single Inheritance)>
Java는 단일상속만을 허용한다. (하나의 부모만 상속)
이는 다중상속시에 있어나는 멤버끼리의 충돌을 막기 위해서다.
다중상속 비슷한 해결책: interface 쓰는 것 | 비중이 높은 클래스 하나만 상속, 나머지는 포함관계로 하는 것
<Object 클래스>
Object 클래스란 모든 클래스의 최고 조상이다.
부모가 없는 클래스는 자동적으로 Object 클래스를 상속받게 된다.
모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받는다. 
(예: toString(), equals(Object obj), hashCode(), …)
extends Object를 안써주면 컴파일러가 자동으로 추가해준다.
Tv와 그 자손인 SmartTv가 있으면 상속 계층도는: Object → Tv → SmartTv이다.
println(참조변수)시 컴파일러가 자동으로 println(참조변수.toString())으로 변환시킨다. 
<오버라이딩(overriding)>
상속받은 조상의 메서드를 자신에 맞게 변경하는 것
내용(구현부)만 변경가능
사용법: 조상에 정의되어있던 메소드의 선언문은 그대로, 내용만 바꿔 쓰면 된다.
오버라이딩의 조건
1. 선언부가 조상 클래스의 메서드와 일치해야 한다.
2. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
3. 조상 클래스의 메서드보다 예외를 많이 선언할 수 없다.
오버로딩 vs. 오버라이딩
- 오버로딩: 기존 메서드와 이름이 같지만 매개변수가 다른 새로운 메서드를 정의하는것 (new)
- 오버라이딩: 상속받은 메서드의 내용을 변경하는 것 (change, modify)
<참조변수 super>
객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자)내에만 존재
조상의 멤버를 자신의 멤버와 구별할 때 사용
<생성자 super()>
조상의 생성자를 호출할 때 사용
조상의 멤버는 조상의 생성자를 호출해서 초기화해야 함
모든 생성자의 첫 줄에 반드시 다른 생성자를 호출해야 한다. 
그렇지 않으면 컴파일러가 생성자의 첫 줄에 조상의 기본생성자 super();를 삽입
이것 때문에 항상 클래스를 만들때 수동적으로 기본생성자를 작성해 줘야 한다.
<패키지(package)>
서로 관련된 클래스의 묶음
클래스는 클래스 파일(*.class), 패키지는 폴더. 하위 패키지는 하위 폴더
클래스의 실제 이름(full name)은 패키지를 포함. (예: java.lang.String)
패키지 선언: 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
선언 방법: package 패키지명.패키지명….
같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.
패키지 선언이 없으면 이름없는 패키지(default package)에 속하게 된다.
클래스 실행법: cmd에서 패키지가 있는 파일로 이동 후, java 패키지명.패키지명.~~.클래스명 입력
<클래스 패스(classpath)>
클래스 파일(*.class)의 위치를 알려주는 경로(path)
환경변수 classpath로 관리하며, 경로간의 구분자는 ‘;’를 사용
classpath(환경변수)에 패키지의 루트를 등록해줘야 함.
설정법: 제어판→시스템 환경 변수 편집→환경 변수(N)...→새로 만들기→변수이름: classpath, 변수 값: 루트
<import 문> ctrl + shift + O
클래스를 사용할 때 패키지 이름을 생략할 수 있다.
컴파일러에게 클래스가 속한 패키지를 알려준다.
선언: import 패키지명.클래스명;
이름이 같은 클래스가 속한 두 패키지를 import 할때는 클래스 이름을 생략하게 해줌
static import 문
- static 멤버 (static 메서드, cv)을 사용할 때, 클래스 이름을 생략하게 해줌
- import static 패키지명.클래스명
<제어자(modifier)>
클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여
접근 제어자: public, protected, (default (기본값)), private
그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp
하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만)
제어자끼리의 순서는 상관이 없지만 대부분 접근 제어자를 맨 앞에 오게 쓴다.
static: 클래스의, 공통적인
           대상: 멤버변수, 메서드
final: 마지막의, 변경될 수 없는
         대상: 클래스 – 변경될 수 없는 클래스, 확장(조상)이 될 수 없는 클래스가 된다.
                  메서드 – 변경될 수 없는 메서드, 오버라이딩을 통해 재정의 불가능
                  멤버변수 – 값을 변경할 수 없는 상수가 됨
                  지역변수 – 값을 변경할 수 없는 상수가 됨 
abstract: 추상의, 미완성의 (추상화)
               대상: 클래스 – 클래스 내에 추상 메서드가 선언되어 있음을 의미함
                        메서드 – 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알림
               상속을 통해 완성시켜줘야 함
<접근 제어자(access modifier)>
public: 접근 제한이 전혀 없음
protected: 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능
(default): 같은 패키지 내에서만 접근이 가능
private: 같은 클래스 내에서만 접근이 가능
접근범위: public > protected > (default) > private
<캡슐화와 접근제어자>
접근 제어자를 사용하는 이유: 
- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
iv를 private으로 해서 직접 접근(참조변수.iv명 = ~)을 막고 메서드를 통해 간접 접근하는 것을 캡슐화라고 함
<다형성(polymorphism)>
여러 가지 형태를 가질 수 있는 능력
조상 타입 참조변수로 자손 타입 객체를 다루는 것  (예: Tv t = new SmartTv();)
하지만, 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없음
참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버개수보다 같거나 적어야 함 (위 문장의 이유)
장점: 1. 다형적 매개변수
         2. 하나의 배열에 여러 종류 객체 저장
<참조변수의 형변환>
사용할 수 있는 멤버의 갯수를 조절하는 것 (리모컨 변경)
조상 - 자손 관계의 참조변수는 서로 형변환 가능
형변환 사용여부를 생각하지 말고 항상 형변환을 사용해 주면 됨
형변환 시 실제 객체가 가지는 멤버개수보다 참조변수의 멤버가 더 많을 수 없음 (오류남)
<instanceof 연산자>
참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환
형변환 전에 반드시 instanceof로 확인해야 함
사용법: 변환할객체 instanceof 변환시킬타입
<매개변수의 다형성>
참조형 매개변수는 메서드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다
<여러종류의 객체를 배열로 다루기>
조상타입의 배열에 자손들의 객체를 담을 수 있음 (다형성 응용)
클래스명 참조변수명 = new 클래스명[n], 참조변수명[0] = new 생성자명(); ……………..
다루고 싶은 객체들의 상속관계를 따져서 가장 가까운 공통조상 클래스타입의 참조변수 배열을 생성해서 객체들을 저장
<추상클래스(abstract class)>
미완성 설계도(제품 생산 불가). 미완성 메서드를 갖고 있는 클래스
다른 클래스 작성에 도움을 주기 위한 것. 인스턴스 생성 불가.
상속을 통해 추상 메서드를 완성해야 인스턴스 생성가능
